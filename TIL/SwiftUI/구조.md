## ContentView
```swift
protocol View {
    assciatedtype Body: View
    var body: Self.Body { get }
}
```
- 기존의 상속과는 달리 View 타입의 프로토콜로 선언.
- View 프로토콜 채택 시 읽기 전용인 body 연산 프로퍼티**만** 필수로 구현해야함
- UIKit에서 UIView 클래스는 많은 프로퍼티를 가지는데 UIView를 상속하면 UIView의 모든 프로퍼티를 사용여부와 상관없이 보유해야 한다는 단점이 있었음
- 하지만 SwiftUI는 필요한 속성만 가지도록 경량화 됨

```swift
struct ContentView: View {
    var body: some View {
        Text("Hello World")
    }
}
```
![body 구조](https://github.com/ChanHyuc/StudySwift/assets/121753386/dbd66c12-28d9-4068-86c4-0d33503b453a)


- body 프로퍼티에서 반환해야 하는 타입이 또 다시 뷰 프로토콜을 준수하는 구조
- 즉 무한 재귀호출이 발생함

```swift
extension Text: View {
    typalias Body = Never
}
```
- 그래서 SwiftUI에서는 Text, Image, Color과 같이 실제 콘텐츠를 표현하는 기본 뷰와 Stack, Group, GeometryReader 같은 컨테이너 뷰에 재귀호출이 일어나지 않게 Never 타입을 사용

### UIHostingViewController
```swift
let contentView = ContentView()
window.rootViewController = UIHostingController(rootView: contentView)
```
- SwiftUI를 이용해 만들어진 뷰를 UIKit 환경에서 사용해야 할 때 사용
- rootViewController 프로퍼티 타입은 UIViewController라서 UIHostingViewController를 이용해 변환해 주는 것

## SwiftUI 구조
```swift
struct ContentView: View {
    var body: some View {
        Text("Hello SwiftUI")
            .font(.title)
            .foregroundColor(.red)
    }
}
```
- "Hello SwiftUI" 텍스트에 font 옵션값이 적용되어 변경된 새로운 뷰가 만들어지고, 그 뷰를 다시 foregroundColor를 감싼 또 다른 뷰가 만들어짐
- 이런식으로 뷰가 중첩되는 구조이며 SwiftUI의 자체적인 렌더 시스템에서 데이터 구조를 효율적으로 축소시켜서 관리됨

```swift
let text = Text("Hello SwiftUI")
text.font = .title
text.foregroundColor = .red
```
- 기존 명령형 문법이였다면 Text 객체의 프로퍼티에 값을 대입하거나 메서드를 호출할 때 한 줄씩 수행했을거임
- 하지만 SwiftUI의 모든 수식어는 자신의 타입이나 뷰 프로토콜을 반환하도록 설계되어 있어서 연쇄적인 메서드 호출(메서드 체이닝) 가능

- SwiftUI 에서는 오토레이아웃이 프레임워크 내부에서 사용되기 때문에 개발자가 직접 다루지 않음
- 그 대신 박스형 레이아웃 시스템과 선언형 문법을 사용해 UI를 배치함
