# Data Structure
- 응용 프로그램 설계 시 중요하게 고려해야 할 항목 중 하나는 데이터 관리
- 입력을 받아 연산하거나 처리한 후 그 결과를 출력하거나 데이터를 보내야 함
- 프로그래머는 데이터를 메모리에 저장하기 위해 여러 자료 구조를 사용할 수 있음
- 성능과 안정성을 확보하려면 상황에 맞는 적절한 **자료 구조**를 선택하는 것이 중요 
- 응용 프로그램이 제대로 작동한다는 것은 기본이고 동시에 지연 시간, 사용 메모리 또는 기타 매개변수 측면에서 최선의 성능을 제공하도록 구현 방법을 선택해야함

## 시간 복잡도(Time Complexity)
- 특정 작업을 수행하는 데 걸리는 시간을 데이터 크기에 대한 수식으로 표현한 것
- 따라서 시간 복잡도는 데이터 크기에 따라서 어떻게 변하는지를 보여줌


## Contiguous Data Structures(연속된 자료 구조)
<img width="565" alt="연속된 자료구조" src="https://github.com/ChanHyuc/StudySwift/assets/121753386/9a8c522f-db56-41ee-a26b-789461a67a61">
- 모든 원소를 단일 메모리 Chunk에 저장함
- 각각의 원소는 같은 Data Type을 사용하고 같은 크기의 메모리를 사용함
- 첫번째 원소의 주소를 Base Address(BA)
- 배열의 전체 크기와 상관없이 모든 원소에 곧바로 접근할 수 있어서 데이터 접근 시간이 항상 일정
- 빅오 표기법으로 나타내면 O(1)
- 배열에는 Static array(정적 배열), Dynamic array(동적 배열)이 있음
- 정적 배열은 Stack 메모리 영역에 할당되기 때문에 함수를 벗어나면 자동으로 해제됨
- 동적 배열은 Heap 영역에 할당되며 사용자가 직접 해제하기 전까지 유지됨
- 배열같은 연속된 자료 구조는 서로 인접해 있기 때문에 원소에 접근할 때 그 옆에 있는 원소의 Cache로 가져옴
- 이를 Cache Locality(캐시 지역성)이라고 하며 시간 복잡도에는 영향을 주지 않음? 
```cpp
int arr[size]   // 정적 배열 선언
int* arr = (int*)malloc(size * sizeof(int));    // C 동적 배열 선언
int* arr = new int[size];   // C++ 동적 배열 선언
```  

## Linked Data Structures(연결된 자료 구조)
<img width="747" alt="연결된 자료구조" src="https://github.com/ChanHyuc/StudySwift/assets/121753386/f4ff8e29-29b9-4992-9e9e-588c83bf47f2">
- Node라고 하는 여러 개의 메모리 Chunk에 데이터를 저장하며 서로 다른 메모리에 데이터가 저장됨
- 각각 노드에 저장할 데이터(data)와 다음 노드를 가리키는 포인터(next)를 가짐
- 맨 마지막 노드는 포인터 대신 자료 구조의 끝을 나타내는 NULL을 가짐
- 특정 원소에 접근하려면 리스트의 시작 부분(head)에서 next 포인터를 따라 차례차례 이동해야함
- 그러므로 원소 접근 시간은 노드 개수에 비례하며 시간 복잡도는 O(n)
- 배열과 달리 연결리스트는 원소의 삽입과 삭제를 빠르게 수행할 수 있음

### 연결리스트 새 원소 추가
<img width="747" alt="연결리스트 새 원소 추가" src="https://github.com/ChanHyuc/StudySwift/assets/121753386/4feb412e-882b-46dd-b373-253c15ddc462">
1. 새로운 원소를 삽입하기 위해 새로운 노드 생성
2. 새로 추가한 노드의 next 포인터가(2번째 next) 다음 노드를(3번째 data)를 가리킴
3. 이전 노드의 next 포인터가(1번째 next) 다음 노드(3번째 data)를 가리켰던것을 제거하고 새로운 노드(2번째 data)를 가르킴
4. 새로운 노드가 연결 리스트에 추가됨
- 기존원소의 삭제도 이것과 비슷한 방식으로 진행됨 


## 연속된 자료구조 연결된 자료구조 비교
|연속된 자료구조|연결된 자료구조|
|:---:|:---:|
|모든 데이터가 메모리에 연속으로 저장|데이터는 노드에 저장되고 노드는 메모리 곳곳에 흩어져 있음|
|임의 원소에 즉시 접근 가능|임의 원소에 접근하는것은 선형 시간 복잡도를 가지며 느린편|
|데이터가 연속적이기 때문에 캐시 지역성 효과로 데이터 순회가 빠름|캐시 지역성이 없으므로 모든 데이터를 순회하는 것이 느린편|
|데이터 저장을 위해 데이터 크기만큼의 메모리 사용|각 노드에서 포인터 저장을 위해 여분의 메모리 사용|
 

### 배열과 연결리스트 시간 복잡도
|파라미터|배열|연결 리스트|
|:---:|:---:|:---:|
|임의 접근|O(1)|O(n)|
|맨 뒤에 원소 삽입|O(1)|O(1)|
|중간에 원소 삽입|O(n)|O(1)|
|캐시 지역성|있음|없음|

